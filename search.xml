<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AndServer+Service 打造 Android 服务器实现 so 文件调用]]></title>
    <url>%2F2019%2F09%2F22%2FAndServer%2BService%E6%89%93%E9%80%A0Android%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0so%E6%96%87%E4%BB%B6%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[so 文件调用随着 Android 移动安全的高速发展，不管是为了执行效率还是程序的安全性等，关键代码下沉 native 层已成为基本操作。native 层的开发就是通指的 JNI/NDK 开发，通过 JNI 可以实现 java 层和 native 层（主要是 C/C++ ）的相互调用，native 层经编译后产生 so 动态链接库，so 文件具有可移植性广，执行效率高，保密性强等优点。那么问题来了，如何调用 so 文件显得异常重要，当然你也可以直接分析 so 文件的伪代码，利用强悍的编程功底直接模拟关键操作，但是我想对于普通人来说头发还是比较重要的。 当前调用 so 文件的主流操作应该是：1，基于 Unicorn 的各种实现（还在学习中，暂且不表）2，Android 服务器的搭建，在 App 内起 http 服务完成调用 so 的需求（当然前提是过了 so 的效验等操作）至于为什么选用 AndServer，好吧，不为什么，只是因为搜索到了它为什么结合 Service，在学习 Android 开发的时候了解到了 Service 的生命周期，个人理解用 Service 去创建 Http 服务比较好。当然也有 Application 的简单使用，因为在正式环境中，大多数 so 文件的逻辑中都有 context 的一些包名了，签名了的效验等，自定义 Application 的话获取 context 传参就好了。 libyemu.so 简介这是我编译好的一个 so 文件，就是根据入参做下简单的字符串拼接（以下是 native 层编译前的 c 代码）123456789101112131415extern &quot;C&quot;JNIEXPORT jstring JNICALLJava_com_fw_myapplication_ndktest_NdkTest_stringFromUTF(JNIEnv *env, jobject instance, jstring str_) &#123; jclass String_clazz = env-&gt;FindClass(&quot;java/lang/String&quot;); jmethodID concat_methodID = env-&gt;GetMethodID(String_clazz, &quot;concat&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;); jstring str = env-&gt;NewStringUTF(&quot; from so --[NightTeam夜幕]&quot;); jobject str1 = env-&gt;CallObjectMethod(str_, concat_methodID, str); const char *chars = env-&gt;GetStringUTFChars((jstring)str1, 0); return env-&gt;NewStringUTF(chars);&#125; 这部分代码还是有必要贴一下的，简单的静态注册使用了反射的思想，反射在逆向中至关重要接下来是 java 代码，定义了 native 函数123456789package com.fw.myapplication.ndktest;public class NdkTest &#123; public static native String stringFromUTF(String str); static &#123; System.loadLibrary(&quot;yemu&quot;); &#125;&#125; 如果到这里有点懵逼的同学可能需要去补下 Android 开发基础了 Android 项目测试 so先说下我的环境，因为这个环境影响太大了1，AndroidStudio 3.42，手机 Android 6 架构 armeabi-v7a打开 AndroidStudio 新建 project在 module 的 build 中加这么一句，然后 sync把编译好的 so 文件复制到 libs 文件夹下（和刚才的 jniLibs.srcDirs 对应）把 so 对应的 java 代码也 copy 过来，注意包名类名的一致性打开 activity_main.xml 文件为 TextView 添加 id打开 MainActiviy.java 开始编码这两行的意思就是，先从布局中找到对应 id 的 TextView，然后为其设置 Text（调用 native 函数的返回值）下面测试一下咱们的 so 调用情况可以看到咱们的 so 文件调用成功（这里咱们的 so 没有效验，只是测试 app 是否可以正常调用） AndServer 代码编写AndServer 官方文档：https://yanzhenjie.com/AndServer/打开官方文档，看看人家的入门介绍，新建 java 文件如图经典 MVC 的 C 就写好了，定义了一个 nightteam_sign 接口，请求方式为 get，请求参数为 sign，调用 native 函数，然后返回 json，但是这里我想利用 Application 获取下 context 对象，取下包名，接下来自定义 Applictaion12345678910111213141516package com.nightteam.httpso;import android.app.Application;public class MyApp extends Application &#123; private static MyApp myApp; public static MyApp getInstance() &#123; return myApp; &#125; @Override public void onCreate() &#123; super.onCreate(); myApp = this; &#125;&#125; 然后在 manifest 文件中指定要启动的 Application然后修改 MyController.java 的代码接下来把官方文档-服务器的代码 copy 下来导入一些包，修改部分代码如下新版本的 AndServer.serverBuilder 已经需要传递 context 了，这里把网络地址和端口号也修改为从构造参数中获取，到这里 AndServer 的东西基本完了，实际上咱们就搭建一个调 so 的接口，并没有过多的业务逻辑，所以代码就是使用的最简单的 Service 代码编写咱们这里用按钮的点击事件启动 Service，故在 activity_main.xml 中添加一个 button 并指定点击事件接下来编写自定义 Service 代码12345678910111213141516171819202122232425262728293031323334353637383940414243package com.nightteam.httpso.Service;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.util.Log;import com.nightteam.httpso.ServerManager;import java.net.InetAddress;import java.net.UnknownHostException;public class MyService extends Service &#123; private static final String TAG = &quot;NigthTeam&quot;; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, &quot;onCreate: MyService&quot;); new Thread() &#123; @Override public void run() &#123; super.run(); InetAddress inetAddress = null; try &#123; inetAddress = InetAddress.getByName(&quot;0.0.0.0&quot;); Log.d(TAG, &quot;onCreate: &quot; + inetAddress.getHostAddress()); ServerManager serverManager = new ServerManager(getApplicationContext(), inetAddress, 8005); serverManager.startServer(); &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; @Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 打上了几个 log，在子线程中启动 AndServer 的服务（何时使用 UI 线程和子线程是 Android 基础，这里就不赘述了）注意一下，这里从 0.0.0.0 获取 inetAddress，可不要写错了，localhost 和 0.0.0.0 的区别请移步搜索引擎然后就是向 ServerManager 的构造函数传递 context，inetAddress，port 用来 new 对象，随后开启服务最后注意检查下 manifest 文件中 Service 的声明 开启 Service，并获取本机 ip回到我们的 MainActivity.java 的 operate（ button 的点击事件）编写启动 Service 代码123456789101112public void operate(View view) &#123; switch (view.getId())&#123; case R.id.id_bt_index: //启动服务:创建--&gt;启动--&gt;销毁 //如果服务已经创建了，后续重复启动，操作的都是同一个服务，不会再重新创建了，除非你先销毁它 Intent it1 = new Intent(this, MyService.class); Log.d(TAG, &quot;operate: button&quot;); startService(it1); ((Button) view).setText(&quot;服务已开启&quot;); break; &#125;&#125; 到这里我们的服务基本搭建好了，但是为了方便起见，我想把咱们的本机 ip 显示在 App 上，这样我们就不用去设置再查看了我在网上找到了一个获取 ip 地址的一个工具类，源码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.nightteam.httpso;import java.net.InetAddress;import java.net.NetworkInterface;import java.net.SocketException;import java.util.Enumeration;import java.util.regex.Pattern;public class NetUtils &#123; private static final Pattern IPV4_PATTERN = Pattern.compile(&quot;^(&quot; + &quot;([0-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])\\.)&#123;3&#125;&quot; + &quot;([0-9]|[1-9][0-9]|1[0-9]&#123;2&#125;|2[0-4][0-9]|25[0-5])$&quot;); private static boolean isIPv4Address(String input) &#123; return IPV4_PATTERN.matcher(input).matches(); &#125; //获取本机IP地址 public static InetAddress getLocalIPAddress() &#123; Enumeration&lt;NetworkInterface&gt; enumeration = null; try &#123; enumeration = NetworkInterface.getNetworkInterfaces(); &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; if (enumeration != null) &#123; while (enumeration.hasMoreElements()) &#123; NetworkInterface nif = enumeration.nextElement(); Enumeration&lt;InetAddress&gt; inetAddresses = nif.getInetAddresses(); if (inetAddresses != null) while (inetAddresses.hasMoreElements()) &#123; InetAddress inetAddress = inetAddresses.nextElement(); if (!inetAddress.isLoopbackAddress() &amp;&amp; isIPv4Address(inetAddress.getHostAddress())) &#123; return inetAddress; &#125; &#125; &#125; &#125; return null; &#125;&#125; 把工具类 copy 到我们的 Android 项目中，继续在 MainActivity.java 中编码获取了一下本机地址和 Android SDK 版本（ Android 8 之后启动 Service 方式不一样） 申请权限，启动 App最后一步就是为 app 申请网络权限了随后连接我们的手机，运行项目，测试一下，点击开启服务看下 AndroidStudio 日志好像一切正常，在浏览器访问下试试（ ip 就是 App 中显示的 ip 地址）如图正常访问到了我们想要的内容回过头来说下 Service，打开我们手机的设置，找到应用程序管理-运行中的服务（手机不同，方式不同）可以看到我们的程序，运行了一个服务，这个服务就是咱们编码的 MyService接下来杀掉该 App进程，再次查看运行中的服务我这里在权限管理设置了自动运行，可以保持服务的运行。（这个地方还是根据系统有大小差异）至此使用 App 起 http 服务调 so 就完成了 好了，上面就是利用 AndServer 打造 Android 服务器调 so 文件的整体思路和流程，如果你懒得看的话，直接用我写好的 App 修修补补也是可以的，只需要发送消息【AndServer搭建Web服务调so】到公众号【NightTeam】即可。]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>AndServer</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将协议规范变成开源库系列之 WebSocket]]></title>
    <url>%2F2019%2F09%2F21%2F%E5%A6%82%E4%BD%95%E5%B0%86%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83%E5%8F%98%E6%88%90%E5%BC%80%E6%BA%90%E5%BA%93%E7%B3%BB%E5%88%97%E4%B9%8BWebSocket%2F</url>
    <content type="text"><![CDATA[这是系列文章的第一篇，也是非常重要的一篇，希望大家能读懂我想要表达的意思。系列文章开篇概述相对于其他编程语言来说，Python 生态中最突出的就是第三方库。任何一个及格的 Python 开发者都使用过至少 5 款第三方库。就爬虫领域而言，必将用到的例如网络请求库 Requests、网页解析库 Parsel 或 BeautifulSoup、数据库对象关系映射 Motor 或 SQLAlchemy、定时任务 Apscheduler、爬虫框架 Scrapy 等。 这些开源库的使用方法想必大家已经非常熟练了，甚至还修炼出了自己的一套技巧，日常工作中敲起键盘肯定也是哒哒哒的响。 但是你有没有想过： 那个神奇的功能是如何实现的？ 这个功能背后的逻辑是什么？ 为什么要这样做而不是选择另一种写法？ 编写这样的库需要用到哪些知识？ 这个论点是否有明确的依据？ 如果你从未这样想过，那说明你还没到达应该「渡劫」的时机；如果你曾提出过 3 个以上的疑问，那说明你即将到达那个重要的关口；如果你常常这么想，而且也尝试着寻找对应的答案，那么恭喜你，你现在正处于「渡劫」的关口之上。 偶有群友会抛出这样的问题：初级工程师、中级工程师、高级工程师如何界定？ 这个问题有两种不同的观点，第一个是看工作职级，第二个则是看个人能力。工作职级是一个浮动很大的参照物，例如阿里巴巴的高级研发和我司的高级研发，职级名称都是「高级研发」，但能力可能会有很大的差距。 个人能力又如何评定呢？ 难不成看代码写的快还是写的慢吗？ 当然不是！ 个人能力应当从广度和深度两个方面进行考量，这并没有一个明确的标准。当两人能力差异很大的时候，外人可以轻松的分辨孰强孰弱。 自己怎样分辨个人能力的进与退呢？ 这就回到了上面提到的那些问题：WHO WHAT WHERE WHY WHEN HOW？ 我想通过这篇文章告诉你，不要做那个用库用得很熟练的人，要做那个创造库的人。计算机世界如此吸引人，就是因为我们可以在这个世界里尽情创造。 你想做一个创造者吗？ 如果不想，那现在你就可以关掉浏览器窗口，回到 Hub 的世界里。 内容介绍这是一套系列文章，这个系列将为大家解读常见库（例如 WebSocket、HTTP、ASCII、Base64、MD5、AES、RSA）的协议规范和对应的代码实现，帮助大家「知其然，知其所以然」。 目标这次我们要学习的是 WebSocket 协议规范和代码实现，也可以理解为从 0 开始编写 aiowebsocket 库。至于为什么选择它，那大概是因为全世界没有比我更熟悉的它的人了。 我是 aiowebsocket 库的作者，我花了 7 天编写这个库。写库的过程，让我深刻体会到造轮子和驾驶的区别，也让我有了飞速的进步。我希望用连载系列文章的形式帮助大家从驾驶者转换到创造者，拥有「编程思考」。 前置条件WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议，它的出现使客户端和服务器之间的数据交换变得更加简单。下图描述了双端交互的流程: WebSocket 通常被应用在实时性要求较高的场景，例如赛事数据、股票证券、网页聊天和在线绘图等。WebSocket 与 HTTP 协议完全不同，但同样被广泛应用。 无论是后端开发者、前端开发者、爬虫工程师或者信息安全工作者，都应该掌握 WebSocket 协议的知识。 我曾经发表过几篇关于 WebSocket 的文章： 【严选-高质量文章】开发者必知必会的 WebSocket 协议 Python如何爬取实时变化的WebSocket数据 WebSocket 从入门到写出开源库 其中，《【严选-高质量文章】开发者必知必会的 WebSocket 协议》介绍了协议规范的相关知识。这篇文章的内容大体如下： WebSocket 协议来源 WebSocket 协议的优点 WebSocket 协议规范 一些实际代码演示 如果没有掌握 WebSocket 协议的朋友，我建议先去阅读这篇文章，尤其是对 WebSocket 协议规范介绍的那部分。 要想将协议规范 RFC6455 变成开源库，第一步就是要熟悉整个协议规范，所以你需要阅读【严选-高质量文章】开发者必知必会的 WebSocket 协议。当然，有能力的同学直接阅读 RFC6455 也未尝不可。 接着还需要了解编程语言中内置库 Socket 的基础用法，例如 Python 中的 socket 或者更高级更潮的 Streams、Transports and Protocols。如果你是 Go 开发者、Rust 开发者，请查找对应语言的内置库。 假设你已经熟悉了 RFC6455，你应该知道 Frame 打包和解包的时候需要用到位运算，正好我之前写过位运算相关的文章 7分钟全面了解位运算。 至于其它的，现用现学吧！ Python 网络通信之 StreamsWebSocket，也可以理解为在 WEB 应用中使用的 Socket，这意味着本篇将会涉及到 Socket 编程。上面提到，Python 中与 Socket 相关的有 socket、Streams、Transports and Protocols。其中 socket 是同步的，而另外两个是异步的，这俩属于你常听到的 asyncio。 Socket 通信过程Socket 是端到端的通信，所以我们要搞清楚消息是怎么从一台机器发送到另一台机器的，这很重要。假设通信的两台机器为 Client 和 Server，Client 向 Server 发送消息的过程如下图所示： Client 通过文件描述符的读写 API read &amp; write 来访问操作系统内核中的网络模块为当前套接字分配的发送 send buffer 和接收 recv buffer 缓存。 Client 进程写消息到内核的发送缓存中，内核将发送缓存中的数据传送到物理硬件 NIC，也就是网络接口芯片 (Network Interface Circuit)。 NIC 负责将翻译出来的模拟信号通过网络硬件传递到服务器硬件的 NIC。 服务器的 NIC 再将模拟信号转成字节数据存放到内核为套接字分配的接收缓存中，最终服务器进程从接收缓存中读取数据即为源客户端进程传递过来的 消息。 上述通信过程的描述和图片均出自钱文品的深入理解 RPC 交互流程。 我尝试寻找通信过程中每个步骤的依据（尤其是 send buffer to NIC to recv buffer），（我翻阅了 TCP 的 RFC 和 Kernel.org）但遗憾的是并未找到有力的证明（一定是我太菜了），如果有朋友知道，可以评论告诉我或发邮件 zenrusts@sina.com 告诉我，我可以扩展出另一篇文章。 创建 Streams那么问题来了：在 Python 中，我们如何实现端到端的消息发送呢？ 答：Python 提供了一些对象帮助我们实现这个需求，其中相对简单易用的是 Streams。 Streams 是 Python Asynchronous I/O 中提供的 High-level APIs。Python 官方文档对 Streams 的介绍如下： Streams are high-level async/await-ready primitives to work with network connections. Streams allow sending and receiving data without using callbacks or low-level protocols and transports. 我尬译一下：Streams 是用于网络连接的 high-level async/await-ready 原语。Streams 允许在不使用回调或 low-level protocols and transports 的情况下发送和接收数据。 Python 提供了 asyncio.open_connection() 让开发者创建 Streams，asyncio.open_connection() 将建立网络连接并返回 reader 和 writer 对象，这两个对象其实是 StreamReader 和 StreamWriter 类的实例。 开发者可以通过 StreamReader 从 IO 流中读取数据，通过 StreamWriter 将数据写入 IO 流。虽然文档并没有给出 IO 流的明确定义，但我猜它跟 buffer （也就是 send buffer to NIC to recv buffer 中的 buffer）有关，你也可以抽象的认为它就是 buffer。 有了 Streams，就有了端到端消息发送的完整实现。下面将通过一个例子来熟悉 Streams 的用法和用途。这是 Python 官方文档给出的双端示例，首先是 Server 端： 1234567891011121314151617181920212223242526272829# TCP echo server using streams# 本文出自「夜幕团队 NightTeam」 转载请联系并取得授权import asyncioasync def handle_echo(reader, writer): data = await reader.read(100) message = data.decode() addr = writer.get_extra_info(&apos;peername&apos;) print(f&quot;Received &#123;message!r&#125; from &#123;addr!r&#125;&quot;) print(f&quot;Send: &#123;message!r&#125;&quot;) writer.write(data) await writer.drain() print(&quot;Close the connection&quot;) writer.close()async def main(): server = await asyncio.start_server( handle_echo, &apos;127.0.0.1&apos;, 8888) addr = server.sockets[0].getsockname() print(f&apos;Serving on &#123;addr&#125;&apos;) async with server: await server.serve_forever()asyncio.run(main()) 接着是 Client 端： 123456789101112131415161718# TCP echo client using streams# 本文出自「夜幕团队 NightTeam」 转载请联系并取得授权import asyncioasync def tcp_echo_client(message): reader, writer = await asyncio.open_connection( &apos;127.0.0.1&apos;, 8888) print(f&apos;Send: &#123;message!r&#125;&apos;) writer.write(message.encode()) data = await reader.read(100) print(f&apos;Received: &#123;data.decode()!r&#125;&apos;) print(&apos;Close the connection&apos;) writer.close()asyncio.run(tcp_echo_client(&apos;Hello World!&apos;)) 将示例分别写入到 server.py 和 client.py 中，然后按序运行。此时 server.py 的窗口会输出如下内容： 1234Serving on (&apos;127.0.0.1&apos;, 8888)Received &apos;Hello World!&apos; from (&apos;127.0.0.1&apos;, 59534)Send: &apos;Hello World!&apos;Close the connection 从输出中得知，服务启动的 address 和 port 为 (&#39;127.0.0.1&#39;, 8888)，从 (&#39;127.0.0.1&#39;, 59534) 读取到内容为 Hello World! 的消息，接着将 Hello World! 返回给 (&#39;127.0.0.1&#39;, 59534) ，最后关闭连接。 client.py 的窗口输出内容如下： 123Send: &apos;Hello World!&apos;Received: &apos;Hello World!&apos;Close the connection 在创建连接后，Client 向指定的端发送了内容为 Hello World! 的消息，接着从指定的端接收到内容为 Hello World! 的消息，最后关闭连接。 有些读者可能不太理解，为什么 Client Send Hello World! ，而 Server 接收到之后也向 Client Send Hello World! 。双端的 Send 和 Received 都是 Hello World! ，这很容易让新手懵逼。实际上这就是一个普通的回显服务器示例，也就是说当 Server 收到消息时，将消息内容原封不动的返回给 Client。 这样只是为了演示，并无它意，但这样的示例却会给新手带来困扰。 以上是一个简单的 Socket 编程示例，整体思路理解起来还是很轻松的，接下来我们将逐步解读示例中的代码： * client.py 中用 `asyncio.open_connection()` 连接指定的端，并获得 reader 和 writer 这两个对象。 * 然后使用 writer 对象中的 `write()` 方法将 `Hello World!` 写入到 IO 流中，该消息会被发送到 Server。 * 接着使用 reader 对象中的 `read()` 方法从 IO 流中读取消息，并将消息打印到终端。 看到这里，你或许会有另一个疑问：write() 只是将消息写入到 IO 流，并没有发送行为，那消息是如何传输到 Server 的呢？ 由于无法直接跟进 CPython 源代码，所以我们无法得到确切的结果。但我们可以跟进 Python 代码，得知消息最后传输到 transport.write() ，如果你想知道更多，可以去看 Transports and Protocols 的介绍。你可以将这个过程抽象为上图的 Client to send buffer to NIC to recv buffer to Server。 功能模块设计通过上面的学习，现在你已经掌握了 WebSocket 协议规范和 Python Streams 的基本用法，接下来就可以设计一个 WebSocket 客户端库了。 根据 RFC6455 的约定，WebSocket 之前是 HTTP，通过「握手」来升级协议。协议升级后进入真正的 WebSocket 通信，通信包含发送（Send）和接收（Recv）。文本消息要在传输过程前转换为 Frames，而接受端读取到消息后要将 Frames 转换成文本。当然，期间会有一些异常产生，我们可能需要自定义异常，以快速定位问题所在。现在我们得出了几个模块： * 握手 - ShakeHands * 传输 - Transports * 帧处理 - Frames * 异常 - Exceptions 一切准备就绪后，就可以进入真正的编码环节了。 由于实战编码篇幅太长，我决定放到下一期，这期的内容，读者们可能需要花费一些时间吸收。 小结开篇我强调了「创造能力」有多么重要，甚至抛出了一些不是很贴切的例子，但我就是想告诉你，不要做调参🐶。 然后我告诉你，本篇文章要讲解的是 WebSocket。 接着又跟你说，要掌握 WebSocket 协议，如果你无法独立啃完 RFC6455，还可以看我写过的几篇关于 WebSocket 文章和位运算文章。 过了几分钟，给你展示了 Socket 的通信过程，虽然没有强有力的依据，但你可以假设这是对的。 喝了一杯白开水之后，我向你展示了 Streams 的具体用法并为你解读代码的作用，重要的是将 Streams 与 Socket 通信过程进行了抽象。 这些前置条件都确定后，我又带着你草草地设计了 WebSocket 客户端的功能模块。 下一篇文章将进入代码实战环节，请做好环境（Python 3.6+）准备。 总之，要想越过前面这座山，就请跟我来！]]></content>
      <categories>
        <category>实用类库</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 搭建商业级 4G 代理]]></title>
    <url>%2F2019%2F09%2F21%2FDocker%E6%90%AD%E5%BB%BA%E5%95%86%E4%B8%9A%E7%BA%A74G%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[大家都知道，现在其实很多爬虫代理都已经并不那么好用了，一些 IP 段被大厂查到，很多大厂的站点可以直接检测到你用了代理，所以爬虫代理也被封得越来越严重了。但是现在代理有一个没有怎么开拓的领域，那就是蜂窝移动，即 4G 代理。目前用 4G 蜂窝移动数据来做代理的相对较少，因此可以算是爬虫代理的一个新的发展方向。但怎么来搭建呢？这就是个问题了。 在开始之前，可能需要大家提前了解一下为什么我们要用 4G 搭建代理，可以看下这篇文章：震惊，商业级4G代理居然只需要用这些…，看完之后，大家再返回到本文就能比较顺畅地切入了。 基本思路从这篇文章的标题中我们可以看出，这一次的搭建方案主要用到的是 Docker，你可能会很好奇，Docker 跟搭建 4G 代理有什么关系吗？ 嗯，关系很大，我们把整件事情梳理一下，先来看看搭建 4G 代理时的基本流程： 调用网卡拨号，拨号成功后会创建一个虚拟网卡。（正常情况下使用这个虚拟网卡就能上网了） 在多网卡的情况下，重复第一步，会得到多个虚拟网卡。 启动代理服务器，使其使用虚拟网卡作为出网网卡，并使用接入内网的实体网卡作为入网网卡。 但是呢，有个问题，根据我之前的测试结果来看，目前在 Linux 环境下还没有一个 HTTP 代理服务器是可以做到分别指定出网网卡和入网网卡的，嗯…这就很麻烦了，因为如果我们无法这么做的话，就会出现类似于下面这样的问题： 出网和入网都在虚拟网卡上，使用代理服务器必须要走公网访问。 入网为实体网卡，但出网被代理服务器锁定为了某一个，无法利用到多网卡。 嗯…那么不用 HTTP 代理服务器，用那些经常被用来做一些骚操作的 Socks5 代理服务器呢？如果可以指定网卡的话，再用像 Privoxy 之类的工具把 Socks5 代理转成 HTTP 代理就好了。（某知名扶墙软件的 Windows 版本就是这么转的 HTTP 代理） 在经过一番尝试后，我发现虽然有些 Socks5 代理服务器的文档中是说可以指定网卡，但按照说明操作后，似乎并不能直接做到我想要的效果（要么还是锁定在某一个上面、要么上不了网），所以还是存在一些问题的。可能是需要配合路由表设置来进行操作吧，不过我对网络工程的了解不怎么深，搞了几天也没搞出来，于是乎还得想想别的办法。 这时候，我想到了一个东西——Docker，它可以用来解决这个问题！ 因为 Docker 容器被创建后，不管外界的网卡有多少个，容器内部的网卡都只会有一个Docker自己的虚拟网卡（容器间通信用的）和一个本地环回接口（不用管它），而且我们在容器内进行拨号操作时，产生的那个新的虚拟网卡也不会影响到外界或其他容器，这样的话，代理服务器就不需要指定网卡了，直接启动就能跑！ 那么现在整个流程就跑通了，进入实际操作环节看看吧！ 系统方面这个 Docker 版的搭建方式，系统方面的选择很多，由于我使用的样例设备是树莓派，所以这里就选择使用了 Raspbian（树莓派专属版 Debian）。如果你使用的是其他设备的话，直接选择一个自己常用的系统就好。 那么准备好之后的第一步当然是先下载并安装 Docker，这里我直接使用 Docker 官方提供的一键安装脚本来进行安装： 123curl -fsSL https://get.docker.com -o get-docker.shsudo sh get-docker.sh# 出自官方文档：https://docs.docker.com/install/linux/docker-ce/debian/#install-using-the-convenience-script 这个一键安装脚本理论上来讲所有 Linux 发行版都可以使用，毕竟已经出来很长时间了，如果不行的话请自行使用搜索引擎查找相关资料。 装好 Docker 之后，你有两个选择： 进入体验模式，了解一下具体操作细节是怎么样的。 不看这一段，翻到本文最下方直接使用我写好的轮子。 启动容器体验的话，我们就直接这么启动一个 Docker 容器吧，执行以下命令： 1sudo docker run -it --rm --privileged -p 3128:3128 ubuntu:18.04 bash 上面这条命令的意思是，启动一个内部系统为 Ubuntu18.04 的容器，并进入容器内部的 Shell 执行 bash 命令，如果退出 bash 就自动销毁容器；然后映射容器内的端口3128到外界，映射出来的外界端口也是3128；最后 privileged 参数是开启特权模式，用于将网卡设备映射进容器内。 如果下载镜像很慢的话，可以搜一下“Docker 加速器”，也可以直接扶墙。 测试一下网卡是否正常进入容器内部后，我们可以执行一下 ls /dev/ttyUSB* 看一下网卡有没有正常被识别出来（在容器外也是一样的，因为开了特权模式），如果是和我买的同一款 4G 网卡的话，在只插入一张网卡的情况下你会看到4个 ttyUSB 设备。 不同 4G 网卡和硬件组合可能会有差异，请以实际情况为准。 如果你可以看到4✖4G网卡个数个 ttyUSB 设备的话，就说明没有问题，可以开始下一步了。 拨号上网接下来要做的就是拨号了，拨号方面可以选择使用 Wvdial 这种工具，也可以选择使用像 Fanconn 这样的商家提供的拨号脚本（直接调用 PPPD），使用起来的效果会有一些区别。如果商家没有提供拨号脚本的话，就用 Wvdial 吧，它能自动生成配置，上手即用。 我这边的话，由于 Fanconn 的技术人员直接提供了个拨号脚本，那我就用这个脚本了，Wvdial 的文档网上有很多很详尽的，这里就不再多提，需要的朋友自行搜索即可。 如果你用的是 Fanconn 的这个拨号脚本（怎么弄进容器内就不用我说了吧？），那么直接在 apt install ppp 安装好拨号工具之后，用 chmod +x quectel-pppd.sh 给拨号脚本加个运行权限，然后 ./quectel-pppd.sh /dev/ttyUSB3 即可。 拨号时使用的 /dev/ttyUSB3 是指 4G 网卡的第四个通信端口，文档中的解释为：ttyUSB3→For PPP connections or AT command communication，翻译一下就是用于 PPP 连接或 AT 命令通信。 拨号之后用 ifconfig 之类的工具即可看到类似下图中的状态： 可以看到，如前文所述，现在有三个网卡，一个是 Docker 自己的、一个是本地环回接口（这个不用管）、一个是拨号产生的虚拟网卡。 如果不是在 Docker 容器内使用的话，还会有个 wwan0（或其他名字），那个是 4G 网卡本体。 测试是否能正常上网现在如果你用 curl 的 --interface 参数指定虚拟网卡进行请求的话（如：curl --interface ppp0 https://ip.cn），是已经可以请求成功的了，IP 也会是你所使用的 SIM 卡对应的运营商分配的。 由于 Docker 的镜像通常都是极度精简的，所以 Ubuntu 镜像里并没有预装像 net-tools、iputils-ping、vim、curl 之类的这些包，需要自行安装。所以如果你发现 ifconfig、ping、curl、vim 用不了，不要惊慌，这是正常现象，执行 apt install 包名 命令安装即可。 如果你无法直接请求成功的话，就可能是 DNS 解析出问题了，可以尝试 ping 一个公网 IP（如：ping 1.1.1.1）和一个域名（如：ping ip.cn），如果 IP 能 ping 通但域名会报 DNS 解析失败的话，就可以确认是 DNS 设置问题了。 4G 拨号时如果出现 DNS 设置问题，通常是因为拨号工具没有正常地将运营商返回的 DNS 服务器设置写入到配置中，我们可以手动配置一下（你要强制指定某一个 DNS 也可以）： 123# 以下为阿里云的公共DNSecho 'nameserver 223.5.5.5' &gt;&gt; /etc/resolv.confecho 'nameserver 223.6.6.6' &gt;&gt; /etc/resolv.conf 在 Docker 容器中，这个 /etc/resolv.conf 文件可能还会有两条内容，是容器本身所需要的，建议不要删除/覆盖，否则会出现容器间无法使用容器名互相通信的情况。 启动代理服务器那么在测试拨号后确实可以通过 4G 网卡上网了之后，我们就可以把代理服务器启动了，这里我使用的是 TinyProxy。 测试发现，Squid 对资源的占用更大一些，不利于多网卡情况下的使用，会影响到 4G 网卡的数量上限。 先 apt install tinyproxy 一波，然后 vim /etc/tinyproxy/tinyproxy.conf 修改一下配置。 要修改的配置主要有： Port 配置项改为3128，因为我们前面映射出来的端口是3128。 Listen 配置项改为0.0.0.0，因为我们需要在其他设备上使用这个代理服务器。 Allow 配置项注释掉或改为0.0.0.0/0，默认的127.0.0.1会导致其他设备无法访问。 改完之后保存一波，然后就可以直接执行 tinyproxy 启动了…吗？ 等等，还有一个操作要做！那就是将默认路由指向到虚拟网卡上，很简单，执行以下命令即可： 12route del -net 0.0.0.0 eth0route add -net 0.0.0.0 ppp0 这两条命令的意思是：先将默认的、指向 eth0 这个网卡的上网路由删除，然后添加一个同样的、指向 ppp0 这个网卡的路由。 改完默认路由后的效果就是，即使你不使用 curl 的 --interface 参数，也能直接使用 4G 网卡上网了。 如果没有改默认路由的话，在不指定网卡的情况下，4G 网卡并不会被使用到，因为默认路由指向的是 Docker 自身的虚拟网卡，那个网卡通向你原本的内网环境。也就是说，IP 不会变！ 那么现在，你可以执行 tinyproxy 启动代理服务器了。 测试代理服务器好了，代理服务器应该已经正常启动了，现在我们可以在另一个设备上尝试连接那个容器中的代理服务器，看看是否能正常通过它使用 4G 网卡上网。 例如我这里树莓派分配到的IP是：192.168.137.66，那么我就可以用这样的 curl 命令或 Python 代码进行测试： curl： 12curl "https://ip.cn"curl -x "192.168.137.66:3128" "https://ip.cn" Python： 12345import requestsresp = requests.get("https://ip.cn", proxies=&#123;"https": "http://192.168.137.66:3128"&#125;)no_proxy_resp = requests.get("https://ip.cn")print(resp.text)print(no_proxy_resp.text) 测试出来的结果应该与前面在容器内部测试时的一致，在使用代理后 IP 就变成了运营商分配的基站 IP。 更换 IP那么最核心的问题来了，怎么更换 IP 呢？ 其实和使用那些拨号 VPS 架设代理服务器一样，我们只需要重新拨个号就能换 IP 了，直接 kill 掉 pppd 进程就可以让它断开拨号，断开后重新执行一遍拨号脚本就是重新拨号了。 断开拨号方面 Fanconn 的技术人员也提供了一个脚本，同样在 chmod +x quectel-ppp-kill 赋予运行权限之后，执行 ./quectel-ppp-kill 就可以了。 但需要注意的是，蜂窝网络的拨号在断开后，IP 仍然会保留一段时间（具体多久不清楚，可能跟连接的基站也有关系），所以我们需要强制性地让网卡重新搜网。 冷门小知识：手机上开启关闭飞行模式的效果就是重新搜网，通常只是关闭“移动数据”的话，效果是与断开拨号一致的。 怎么做呢？很简单，就两行命令： 12AT+CFUN=0AT+CFUN=1 但注意哦，这是 AT 命令，不是 Linux 下的 Shell 命令，AT 命令是一种调制解调器命令语言，我们如果需要将它执行起来，需要这么做： 123echo "AT+CFUN=0" &gt; /dev/ttyUSB2# 中间间隔1秒左右echo "AT+CFUN=1" &gt; /dev/ttyUSB2 这里使用的 /dev/ttyUSB2 是指 4G 网卡的第三个通信端口，文档中的解释为：ttyUSB2→For AT command communication，与第四个通信端口类似，只是它不能用于 PPP 连接、只能用于 AT 命令通信而已。 不同样使用第四个通信端口的原因是那个端口有被占用的可能性，直接区分开最稳妥，本来网卡也就是提供了两个 AT 命令通信渠道的。 在使网卡重新搜网后的几秒至十几/几十秒内的时间里，你无法正常拨号，需要等待它初始化完成后才可以拨号成功，具体等待时间以信号强度为准，我测试的时候通常5秒以内就可以了。 所以如果你在断开后一直拨号失败，不妨过一会儿再试。 总结那么现在操作流程也跑通了，我们也了解到了整个的内部细节，最后要做的就是把每个网卡都分别分配一个容器，这样我们就能实现文章开头所提到的——“使用虚拟网卡作为出网网卡，并使用接入内网的实体网卡作为入网网卡”的效果了。 实际操作起来的话，就是把指定网卡的部分给配置化，然后在启动容器的时候传入就好了，使用 Docker 的容器环境变量相关设置可以很轻松地实现这个功能。 最后，我们可以以这个思路，构建一个 docker-compose 模板，模板的核心内容一是做个简易的4G网卡容器集群，二是启动个 Squid，用来聚合代理服务器，这样我们使用的时候只需要指定一个代理服务器就能随机更换了，操作起来更加方便。 好了，上面就是 Docker 版搭建方式的思路和整个的搭建流程，如果你懒得看的话，直接用我写好的轮子也是可以的，只需要发送消息【Docker版4G代理】到公众号【NightTeam】即可。 评价最后的最后，我给这个搭建方式打个评价吧。 这个搭建方式并不完美，因为变量太多，而且很多地方肯定不如系统级原生支持的那么稳定，长期使用可能会出现各种奇奇怪怪的问题。 然后 Docker 的资源占用其实挺高的，会浪费相当多的内存在启动容器上，如果只是两三个网卡还好，如果数量大一点的话，像树莓派2B 这种小内存的设备根本就扛不住。 另外代理服务器本身对资源的消耗也是比较高的，高频调用下对树莓派2B 的小 CPU 压力还是蛮大的，即使我对它的 CPU 进行了超频，在并发测试时也还是会出现轻松打满 CPU 的情况。 但是！截止目前，我还有两种基于路由器系统的搭建方案没写出来！所以…敬请期待后续的其他搭建方案。]]></content>
      <categories>
        <category>代理</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>4G</tag>
        <tag>代理</tag>
      </tags>
  </entry>
</search>
